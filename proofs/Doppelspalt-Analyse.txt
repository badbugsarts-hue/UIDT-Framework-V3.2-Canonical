import numpy as np
import matplotlib.pyplot as plt
from scipy.special import sinc
import matplotlib.style as mplstyle
mplstyle.use('fast')

class DoubleSlitExperiment:
    def __init__(self, wavelength=632.8e-9, slit_separation=0.5e-3, 
                 screen_distance=2.0, slit_width=0.1e-3):
        """
        Quantenmechanische Simulation des Doppelspalt-Experiments
        
        Parameter:
        - wavelength: WellenlÃ¤nge in Metern (632.8 nm = rotes Laserlicht)
        - slit_separation: Spaltabstand in Metern (0.5 mm)
        - screen_distance: Schirmabstand in Metern (2.0 m)
        - slit_width: Spaltbreite in Metern (0.1 mm)
        """
        self.wavelength = wavelength
        self.slit_separation = slit_separation
        self.screen_distance = screen_distance
        self.slit_width = slit_width
        
        # Fundamentale Konstanten
        self.h = 6.626e-34  # Planck-Konstante [JÂ·s]
        self.c = 3e8        # Lichtgeschwindigkeit [m/s]
        
    def single_slit_pattern(self, y):
        """
        Beugungsmuster eines Einzelspalts (sinc-Funktion)
        """
        theta = np.arctan(y / self.screen_distance)
        beta = (np.pi * self.slit_width * np.sin(theta)) / self.wavelength
        return (sinc(beta / np.pi))**2
    
    def double_slit_interference(self, y):
        """
        Interferenzmuster des Doppelspalts
        """
        theta = np.arctan(y / self.screen_distance)
        
        # Einzelspalt-Beugung
        single_slit = self.single_slit_pattern(y)
        
        # Doppelspalt-Interferenz
        delta = (2 * np.pi * self.slit_separation * np.sin(theta)) / self.wavelength
        interference = np.cos(delta/2)**2
        
        return single_slit * interference
    
    def calculate_maxima_minima(self):
        """
        Berechnet Positionen der Interferenzmaxima und -minima
        """
        maxima_positions = []
        minima_positions = []
        
        for m in range(-5, 6):  # Bis zur 5. Ordnung
            # Maxima: m * Î» * L / d
            y_max = m * self.wavelength * self.screen_distance / self.slit_separation
            maxima_positions.append(y_max)
            
            # Minima: (m + 0.5) * Î» * L / d  
            y_min = (m + 0.5) * self.wavelength * self.screen_distance / self.slit_separation
            minima_positions.append(y_min)
        
        return maxima_positions, minima_positions
    
    def quantum_probability_density(self, y, which_path_detection=False):
        """
        Quantenmechanische Wahrscheinlichkeitsdichte
        mit/ohne Welcher-Weg-Information
        """
        if which_path_detection:
            # Mit Welcher-Weg-Information: Interferenz verschwindet
            return self.single_slit_pattern(y) * 2  # Einfache Summe
        else:
            # Ohne Welcher-Weg-Information: VollstÃ¤ndige Interferenz
            return self.double_slit_interference(y)
    
    def plot_complete_analysis(self):
        """
        Erstellt vollstÃ¤ndige Analyse mit mehreren Subplots
        """
        fig = plt.figure(figsize=(15, 10))
        
        # Bereich auf dem Schirm [m]
        y = np.linspace(-0.02, 0.02, 1000)  # Â±2 cm
        
        # 1. Hauptplot: Vergleich Teilchen vs. Welle vs. Quanten
        ax1 = plt.subplot(2, 2, 1)
        
        # Klassische Teilchen (zwei Peaks)
        particle_pattern = np.exp(-(y - self.slit_separation/2)**2 / (2*(0.001)**2)) + \
                          np.exp(-(y + self.slit_separation/2)**2 / (2*(0.001)**2))
        
        # Quantenmechanisches Interferenzmuster
        quantum_pattern = self.double_slit_interference(y)
        
        plt.plot(y * 1000, particle_pattern / np.max(particle_pattern), 
                'r--', label='Klassische Teilchen', linewidth=2)
        plt.plot(y * 1000, quantum_pattern, 'b-', label='Quantenobjekte', linewidth=2)
        
        # Markiere Maxima und Minima
        maxima, minima = self.calculate_maxima_minima()
        for y_max in maxima:
            if abs(y_max) <= 0.02:
                plt.axvline(y_max * 1000, color='green', linestyle=':', alpha=0.7)
        for y_min in minima:
            if abs(y_min) <= 0.02:
                plt.axvline(y_min * 1000, color='red', linestyle=':', alpha=0.7)
        
        plt.xlabel('Position auf Schirm [mm]')
        plt.ylabel('Relative IntensitÃ¤t')
        plt.title('Doppelspalt-Experiment: Teilchen vs. Quanten')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # 2. Beobachtereffekt
        ax2 = plt.subplot(2, 2, 2)
        
        pattern_without_detector = self.quantum_probability_density(y, False)
        pattern_with_detector = self.quantum_probability_density(y, True)
        
        plt.plot(y * 1000, pattern_without_detector, 'g-', 
                label='Ohne Weg-Detektion', linewidth=2)
        plt.plot(y * 1000, pattern_with_detector, 'm--', 
                label='Mit Weg-Detektion', linewidth=2)
        
        plt.xlabel('Position auf Schirm [mm]')
        plt.ylabel('Wahrscheinlichkeitsdichte')
        plt.title('Beobachtereffekt: Kollaps der Wellenfunktion')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # 3. Einzelspalt vs. Doppelspalt
        ax3 = plt.subplot(2, 2, 3)
        
        single_slit = self.single_slit_pattern(y)
        double_slit = self.double_slit_interference(y)
        
        plt.plot(y * 1000, single_slit, 'orange', label='Einzelspalt', linewidth=2)
        plt.plot(y * 1000, double_slit, 'purple', label='Doppelspalt', linewidth=2)
        
        plt.xlabel('Position auf Schirm [mm]')
        plt.ylabel('Relative IntensitÃ¤t')
        plt.title('Vergleich: Einzelspalt vs. Doppelspalt')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        # 4. Parameter-Einfluss
        ax4 = plt.subplot(2, 2, 4)
        
        # Variiere WellenlÃ¤nge
        wavelengths = [400e-9, 532e-9, 632.8e-9, 700e-9]  # Verschiedene Farben
        colors = ['violet', 'green', 'red', 'darkred']
        
        for wl, color in zip(wavelengths, colors):
            temp_exp = DoubleSlitExperiment(wavelength=wl)
            pattern = temp_exp.double_slit_interference(y)
            plt.plot(y * 1000, pattern, color=color, 
                    label=f'Î» = {wl*1e9:.0f} nm', linewidth=2)
        
        plt.xlabel('Position auf Schirm [mm]')
        plt.ylabel('Relative IntensitÃ¤t')
        plt.title('Einfluss der WellenlÃ¤nge')
        plt.legend()
        plt.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
        return fig

    def print_physical_parameters(self):
        """
        Gibt wichtige physikalische Parameter aus
        """
        print("ðŸ”¬ PHYSIKALISCHE PARAMETER DES EXPERIMENTS")
        print("=" * 50)
        print(f"WellenlÃ¤nge Î»: {self.wavelength * 1e9:.1f} nm")
        print(f"Spaltabstand d: {self.slit_separation * 1e3:.2f} mm")
        print(f"Spaltbreite a: {self.slit_width * 1e3:.2f} mm") 
        print(f"Schirmabstand L: {self.screen_distance:.1f} m")
        
        # Berechne charakteristische GrÃ¶ÃŸen
        fringe_spacing = self.wavelength * self.screen_distance / self.slit_separation
        angular_spacing = self.wavelength / self.slit_separation
        
        print(f"\nðŸ“ CHARAKTERISTISCHE GRÃ–SSEN:")
        print(f"Streifenabstand Î”y: {fringe_spacing * 1e3:.2f} mm")
        print(f"Winkelabstand Î”Î¸: {angular_spacing * 1e3:.2f} mrad")
        
        # Maxima-Positionen
        maxima, minima = self.calculate_maxima_minima()
        print(f"\nðŸŽ¯ INTERFERENZORDNUNGEN (bis 3. Maximum):")
        for m, y_max in enumerate(maxima):
            if abs(m-2) <= 3:  # Zeige nur Â±3 Ordnungen um die Mitte
                print(f"  Maximum m={m-2}: y = {y_max * 1e3:+.2f} mm")

# Quantenmechanische Erweiterung
class QuantumDoubleSlit(DoubleSlitExperiment):
    def __init__(self, particle_mass=9.11e-31, particle_energy=100, **kwargs):
        """
        Erweiterung fÃ¼r massive Quantenteilchen (Elektronen)
        
        Parameter:
        - particle_mass: Masse des Teilchens [kg] (9.11e-31 kg fÃ¼r Elektron)
        - particle_energy: Energie in eV (100 eV typisch fÃ¼r Elektronen)
        """
        super().__init__(**kwargs)
        self.particle_mass = particle_mass
        self.particle_energy = particle_energy  # in eV
        
        # Berechne de Broglie WellenlÃ¤nge
        self.de_broglie_wavelength = self.calculate_de_broglie_wavelength()
        
    def calculate_de_broglie_wavelength(self):
        """Berechnet de Broglie WellenlÃ¤nge fÃ¼r massive Teilchen"""
        # Energie in Joule umrechnen
        E_joule = self.particle_energy * 1.602e-19  # eV to J
        
        # Impuls berechnen: p = âˆš(2mE)
        momentum = np.sqrt(2 * self.particle_mass * E_joule)
        
        # de Broglie: Î» = h/p
        return self.h / momentum
    
    def electron_interference_pattern(self, y):
        """Interferenzmuster fÃ¼r Elektronen"""
        # Verwende de Broglie WellenlÃ¤nge statt LichtwellenlÃ¤nge
        original_wl = self.wavelength
        self.wavelength = self.de_broglie_wavelength
        
        pattern = self.double_slit_interference(y)
        
        # Stelle ursprÃ¼ngliche WellenlÃ¤nge wieder her
        self.wavelength = original_wl
        return pattern

# Demonstration
def demonstrate_quantum_paradox():
    """
    Demonstriert das quantenmechanische Paradoxon
    """
    print("ðŸ¤” QUANTENPARADOXON DES DOPPELSPALTS")
    print("=" * 60)
    
    print("""
    PARADOXON 1: Welle-Teilchen-DualitÃ¤t
    â€¢ Einzelnes Teilchen â†’ Punkt am Schirm (Teilcheneigenschaft)
    â€¢ Viele Teilchen â†’ Interferenzmuster (Welleneigenschaft)
    â€¢ Aber: Jedes einzelne Teilchen 'weiÃŸ' vom gesamten Aufbau!
    
    PARADOXON 2: Welcher-Weg-Information
    â€¢ Ohne Detektor: Interferenzmuster (Teilchen geht beide Wege)
    â€¢ Mit Detektor: Zwei Streifen (Teilchen wÃ¤hlt einen Weg)
    â€¢ Die Messung beeinflusst das Ergebnis fundamental!
    
    PARADOXON 3: Selbstinterferenz
    â€¢ Das Teilchen interferiert mit sich selbst
    â€¢ Es muss durch BEIDE Spalte gleichzeitig gehen
    â€¢ Dies wird mathematisch durch die Wellenfunktion Ïˆ beschrieben
    """)
    
    # Erstelle Experiment-Instanz
    exp = DoubleSlitExperiment()
    exp.print_physical_parameters()
    
    print("\nðŸŽ­ QUANTENMECHANISCHE INTERPRETATION:")
    print("""
    Die Wellenfunktion Ïˆ(x) beschreibt die Wahrscheinlichkeitsamplitude.
    â€¢ |Ïˆ(x)|Â² gibt die Aufenthaltswahrscheinlichkeit an
    â€¢ Vor der Messung: Ïˆ = Ïˆ_links + Ïˆ_rechts (Superposition)
    â€¢ Bei Messung: Kollaps zu entweder |LinksâŸ© oder |RechtsâŸ©
    
    Mathematisch:
    P(y) = |Ïˆâ‚(y) + Ïˆâ‚‚(y)|Â² = |Ïˆâ‚|Â² + |Ïˆâ‚‚|Â² + 2Re(Ïˆâ‚*Ïˆâ‚‚)
                       â†‘
                Interferenzterm
    """)

# HauptausfÃ¼hrung
if __name__ == "__main__":
    # Zeige das Paradoxon
    demonstrate_quantum_paradox()
    
    # Erstelle und plotte das Experiment
    experiment = DoubleSlitExperiment()
    fig = experiment.plot_complete_analysis()
    
    # Elektronen-Experiment demonstrieren
    print("\nâš›ï¸  ELEKTRONEN-DOPPELSPALT-EXPERIMENT")
    print("=" * 50)
    
    electron_exp = QuantumDoubleSlit(particle_mass=9.11e-31, particle_energy=100)
    electron_wavelength = electron_exp.de_broglie_wavelength
    
    print(f"De Broglie WellenlÃ¤nge fÃ¼r 100 eV Elektronen:")
    print(f"Î» = {electron_wavelength * 1e12:.2f} pm (Pikometer)")
    print(f"Vergleich: Sichtbares Licht Î» â‰ˆ 400-700 nm")
    print(f"â†’ ElektronenwellenlÃ¤nge ist ~1000Ã— kleiner!")
    
    # Vergleich Elektronen vs. Licht
    y = np.linspace(-0.01, 0.01, 1000)
    electron_pattern = electron_exp.electron_interference_pattern(y)
    light_pattern = experiment.double_slit_interference(y)
    
    plt.figure(figsize=(10, 6))
    plt.plot(y * 1000, electron_pattern / np.max(electron_pattern), 
             'r-', label='Elektronen (100 eV)', linewidth=2)
    plt.plot(y * 1000, light_pattern, 'b-', label='Licht (632.8 nm)', linewidth=2)
    plt.xlabel('Position auf Schirm [mm]')
    plt.ylabel('Relative IntensitÃ¤t / Wahrscheinlichkeit')
    plt.title('Vergleich: Elektronen vs. Licht am Doppelspalt')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()

Das Doppelspalt-Experiment ist das zentrale Gedankenexperiment der Quantenmechanik und demonstriert die Wellen-Teilchen-DualitÃ¤t von Materie und Licht.
ðŸ”¬ ErklÃ¤rung des Doppelspalt-Experiments
Aufbau
Das Experiment besteht aus einer Quelle (z.B. einem Laser oder einem Elektronenstrahler), einer Barriere mit zwei eng beieinander liegenden Spalten (Doppelspalt) und einem Schirm (oder Detektor) dahinter.
1. Klassische Erwartung (Teilchen vs. Wellen)
 * Klassische Teilchen (z.B. Kugeln): Man wÃ¼rde erwarten, dass die Teilchen entweder durch den linken oder den rechten Spalt gehen und zwei helle Streifen auf dem Schirm erzeugen, die genau hinter den Spalten liegen.
 * Klassische Wellen (z.B. Wasserwellen): Man wÃ¼rde erwarten, dass die Wellen nach dem Passieren der beiden Spalte interferieren und ein Interferenzmuster aus abwechselnden Maxima (konstruktive Interferenz) und Minima (destruktive Interferenz) erzeugen.
2. Quantenmechanische Beobachtung
Werden elementare Quantenobjekte (wie Elektronen, Photonen oder sogar kleine MolekÃ¼le wie Fullerene) durch den Doppelspalt geschickt, geschieht Folgendes:
 * Massenhafter Beschuss: Wenn viele Teilchen gleichzeitig geschickt werden, baut sich auf dem Schirm ein klares Interferenzmuster auf â€“ genau wie bei klassischen Wellen.
 * Einzelschuss: Werden die Teilchen so langsam nacheinander geschickt, dass sich zu jedem Zeitpunkt nur ein Teilchen im Experiment befindet, bildet sich trotzdem das Interferenzmuster.
 * Beobachtereffekt: Sobald ein Detektor an einem der Spalte platziert wird, um festzustellen, welchen Weg das Teilchen genommen hat, verschwindet das Interferenzmuster sofort, und es entstehen nur die zwei klassischen Streifen.
3. Schlussfolgerung
Das Ergebnis zeigt die Wellen-Teilchen-DualitÃ¤t:
 * Das Teilchen breitet sich als Welle aus (Superposition), solange es unbeobachtet ist, und geht scheinbar beide Wege gleichzeitig, um mit sich selbst zu interferieren.
 * Das Teilchen kollabiert zu einem Teilchen (Kollaps der Wellenfunktion), sobald es am Schirm detektiert oder am Spalt beobachtet wird.
ðŸ“ Berechnung der Interferenzmuster
Die Position der Interferenzstreifen (Maxima und Minima) hÃ¤ngt vom Gangunterschied \Delta s ab, den die Welle vom jeweiligen Spalt bis zu einem Punkt P auf dem Schirm zurÃ¼cklegt.
Geometrie
 * Spaltabstand: d
 * Abstand zum Schirm: L
 * WellenlÃ¤nge der Teilchen: \lambda (bestimmt durch die De-Broglie-Beziehung: \lambda = h/p, wobei h das Plancksche Wirkungsquantum und p der Impuls ist).
 * Position auf dem Schirm: y (gemessen von der Mitte).
 * Winkel: \alpha (Winkel zwischen der Mitte des Spaltes und dem Punkt P auf dem Schirm).
Gangunterschied \Delta s
FÃ¼r kleine Winkel (\sin \alpha \approx \tan \alpha \approx \alpha) gilt:


Da \tan \alpha = y/L ist, kann \sin \alpha nÃ¤herungsweise durch y/L ersetzt werden:

1. Maxima (Konstruktive Interferenz)
Ein Maximum (heller Streifen) entsteht, wenn der Gangunterschied \Delta s ein ganzzahliges Vielfaches der WellenlÃ¤nge \lambda ist.
Position der Maxima (y_m):

2. Minima (Destruktive Interferenz)
Ein Minimum (dunkler Streifen) entsteht, wenn der Gangunterschied \Delta s ein halbzahliges Vielfaches der WellenlÃ¤nge \lambda ist.
Position der Minima (y_m):

Streifenabstand
Der Abstand zwischen zwei benachbarten Maxima (z.B. m=0 und m=1) ist der Streifenabstand \Delta y:
Fazit: Der Streifenabstand ist direkt proportional zur WellenlÃ¤nge \lambda und zum Abstand L des Schirms, aber umgekehrt proportional zum Abstand d der Spalte. Je enger die Spalte beieinander liegen (d klein) oder je grÃ¶ÃŸer die WellenlÃ¤nge \lambda ist, desto breiter werden die Interferenzstreifen.
